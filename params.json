{
  "name": "Binarylogic",
  "tagline": "Binary Logic GNU R Package",
  "body": "<!-- README.md is generated from README.Rmd. Please edit that file -->\r\nbinaryLogic\r\n===========\r\n\r\n[![Build Status](https://travis-ci.org/d4ndo/binaryLogic.png)](https://travis-ci.org/d4ndo/binaryLogic) [![Downloads](http://cranlogs.r-pkg.org/badges/binaryLogic?color=brightgreen)](http://www.r-pkg.org/pkg/binaryLogic) [![CRAN version](http://www.r-pkg.org/badges/version/binaryLogic)](http://cran.r-project.org/package=binaryLogic)\r\n\r\nBinary Logic GNU R Package\r\n\r\nConvert, negate, shift and rotate binary digits. (switchEndianess, bin2gray, bytesNeeded, binaryPrefix, fillUpToByte).\r\n\r\nInstallation\r\n------------\r\n\r\ndevtools are required to install \"binaryLogic\" from github: [devtools](https://github.com/hadley/devtools)\r\n\r\n``` r\r\nlibrary(devtools)\r\n\r\n# install 'binaryLogic'\r\ninstall_github(\"d4ndo/binaryLogic\")\r\nlibrary(binaryLogic)\r\n```\r\n\r\nGetting started\r\n---------------\r\n\r\nStarting with a simple conversion. Decimal (Base10) to binary (Base2) and vice versa.\r\n\r\n``` r\r\nthe_answer_to_the_ultimate_question_of_life_the_universe_and_everything <- as.binary(42)\r\n\r\nthe_answer_to_the_ultimate_question_of_life_the_universe_and_everything\r\n#> [1] 1 0 1 0 1 0\r\n\r\nas.numeric(the_answer_to_the_ultimate_question_of_life_the_universe_and_everything)\r\n#> [1] 42\r\n\r\nsummary(the_answer_to_the_ultimate_question_of_life_the_universe_and_everything)\r\n#>   Signedness  Endianess value<0 Size[bit] Base10\r\n#> 1   unsigned Big-Endian   FALSE         6     42\r\n```\r\n\r\nOperator\r\n--------\r\n\r\nBehavior »Class Binary«\r\n\r\n| Operator              | Behavior                                                        |\r\n|:----------------------|:----------------------------------------------------------------|\r\n| [== or !=]            | Comparision by value.                                           |\r\n| [\\<, \\<= or \\> , \\>=] | Comparision by value.                                           |\r\n| [+ or -]              | Operations by value.                                            |\r\n| [\\*, ^]               | Operations by value.                                            |\r\n| [%/%, %%]             | Operations by value                                             |\r\n| [/]                   | Not supported.                                                  |\r\n| [&, ¦, xor]           | Bitwise Operations. The smaller vector is filled up with zeros. |\r\n| [!]                   | Indicates logical negation (NOT). Bitwise Operations            |\r\n\r\nThe logical == operator compares every element of the vector (Bitwise comparison). e.g.\r\n\r\n``` r\r\ntwo <- as.binary(2); two <- as.logical(two); two == two;\r\n#> [1] TRUE TRUE\r\n```\r\n\r\nThe binary == operator compares the value and it does not distinguish between big and little endian.\r\n\r\n``` r\r\ntwo <- as.binary(2); two == two;\r\n#> [1] TRUE\r\n```\r\n\r\nBinaryLogic operators:\r\n\r\n| Operator                              | Behavior                                               |\r\n|:--------------------------------------|:-------------------------------------------------------|\r\n| shiftLeft(binary), shiftRight(binary) | shift Operation.                                       |\r\n| rotate(binary)                        | shift Operation.                                       |\r\n| negate(binary)                        | Indicates arithmetic negation. value \\<- value \\* (-1) |\r\n| switchEndianess(binary)               |                                                        |\r\n| bin2gray(binary)                      | convert binary to gray code                            |\r\n| gray2bin(gray)                        | convert gray code to binary                            |\r\n\r\nInformation\r\n-----------\r\n\r\nThis class is just not that great at heavy number crunching, but it brings some benefits. Especially if you like to work using vectors in R. The »binary« class inherits from the »logical« class. Some function from package `binaryLogic` can be applied to logical vectors such as shift or rotate (see help).\r\n\r\nThe internal structure looks like this. It is composed of a »logical vector« and several attributes. In this example(Big-Endian), it corresponds to the value = 2(Base10).\r\n\r\n``` r\r\nstructure(c(TRUE, FALSE), class = c(\"binary\", \"logical\"), signed = FALSE, littleEndian = FALSE)\r\n#> [1] 1 0\r\n```\r\n\r\nThe binary number is represented by a logical vector. The Bit order usually follows the same endianess as the byte order. How to read:\r\n\r\n-   Little Endian (LSB) —\\> (MSB)\r\n\r\n-   Big Endian (MSB) \\<— (LSB)\r\n\r\nThe Big Endian endianess stores its MSB at the lowest adress. The Little Endian endianess stores its MSB at the highest adress.\r\n\r\ne.g.\r\n\r\n``` r\r\nb <-binary(8)\r\nb\r\n#> [1] 0 0 0 0 0 0 0 0\r\n```\r\n\r\n-   »Little Endian« : MSB at b[1] and LSB at b[8].\r\n\r\n-   »Big Endian« : LSB at b[1] and MSB at b[8].\r\n\r\n##### Signed digit:\r\n\r\nCalculation:\r\n\r\nThe size has to be considerd in a calculation with a signed number. e.G.: An 8 Bit signed number can hold this range of base10 numbers [127 to -128]. You will run into a problem if a calculation is outside of this range. The reference is the larger number in size.\r\n\r\nSize:\r\n\r\nThe size »must« be specified. In Byte e.G. (1 Byte = 8 Bit, 2 Byte, .. n Byte). By default it is 2 Byte.\r\n\r\n##### Unsigned digit:\r\n\r\nCalculation:\r\n\r\nAn unsigned number will increase it's size when caluculation is not in range.\r\n\r\nSize:\r\n\r\nThe size »can« be specified. In Bit. (1 Bit , 2 Bit, .. n Bit). There is no default size because the size is calculated on the fly.\r\n\r\nMore Converting\r\n---------------\r\n\r\n### Integer\r\n\r\n``` r\r\nas.binary(0xAF)\r\n#> [1] 1 0 1 0 1 1 1 1\r\n\r\nas.binary(42)\r\n#> [1] 1 0 1 0 1 0\r\n\r\nas.binary(42, littleEndian=TRUE)\r\n#> [1] 0 1 0 1 0 1\r\n\r\nas.binary(c(0xAF, 0xBF, 0xFF))\r\n#> [[1]]\r\n#> [1] 1 0 1 0 1 1 1 1\r\n#> \r\n#> [[2]]\r\n#> [1] 1 0 1 1 1 1 1 1\r\n#> \r\n#> [[3]]\r\n#> [1] 1 1 1 1 1 1 1 1\r\n\r\nas.binary(c(2,4,8,16), signed=TRUE, size=1)\r\n#> [[1]]\r\n#> [1] 0 0 0 0 0 0 1 0\r\n#> \r\n#> [[2]]\r\n#> [1] 0 0 0 0 0 1 0 0\r\n#> \r\n#> [[3]]\r\n#> [1] 0 0 0 0 1 0 0 0\r\n#> \r\n#> [[4]]\r\n#> [1] 0 0 0 1 0 0 0 0\r\n\r\nas.binary(-1, signed=TRUE, size=1)\r\n#> [1] 1 1 1 1 1 1 1 1\r\n```\r\n\r\nother way around\r\n\r\n``` r\r\ntwo <- as.binary(2, signed=TRUE, size=4)\r\nas.integer(negate(two))\r\n#> [1] -2\r\n# or\r\nas.double(two)\r\n#> [1] 2\r\n# alias for\r\nas.numeric(two)\r\n#> [1] 2\r\n```\r\n\r\n### Logical\r\n\r\n``` r\r\nas.binary(c(1,1,0), signed=TRUE, logic=TRUE)\r\n#> [1] 0 0 0 0 0 1 1 0\r\n\r\nas.binary(c(TRUE,TRUE,FALSE), logic=TRUE)\r\n#> [1] 1 1 0\r\n\r\nbigEndian <- as.binary(c(1,1,0,0), logic=TRUE)\r\nsummary(bigEndian)\r\n#>   Signedness  Endianess value<0 Size[bit] Base10\r\n#> 1   unsigned Big-Endian   FALSE         4     12\r\n\r\nlittleEndian <- switchEndianess(bigEndian)\r\nprint(littleEndian)\r\n#> [1] 0 0 1 1\r\n\r\nlittleEndian <- as.binary(bigEndian, littleEndian=TRUE)\r\nprint(littleEndian)\r\n#> [1] 1 1 0 0\r\n\r\nsummary(littleEndian)\r\n#>   Signedness     Endianess value<0 Size[bit] Base10\r\n#> 1   unsigned Little-Endian   FALSE         4      3\r\n```\r\n\r\nother way around\r\n\r\n``` r\r\nas.logical(as.binary(2))\r\n#> [1]  TRUE FALSE\r\n```\r\n\r\n### Raw\r\n\r\n``` r\r\nb <- as.binary(charToRaw(\"A\"))\r\nsummary(b)\r\n#>   Signedness  Endianess value<0 Size[bit] Base10\r\n#> 1   unsigned Big-Endian   FALSE         7     65\r\n\r\nas.raw(b)\r\n#> [1] 41\r\n```\r\n\r\n### Gray code\r\n\r\n``` r\r\nb <- as.binary(0:7, n=3)\r\ng <- lapply(b, bin2gray)\r\nprint(g)\r\n#> [[1]]\r\n#> [1] FALSE FALSE FALSE\r\n#> \r\n#> [[2]]\r\n#> [1] FALSE FALSE  TRUE\r\n#> \r\n#> [[3]]\r\n#> [1] FALSE  TRUE  TRUE\r\n#> \r\n#> [[4]]\r\n#> [1] FALSE  TRUE FALSE\r\n#> \r\n#> [[5]]\r\n#> [1]  TRUE  TRUE FALSE\r\n#> \r\n#> [[6]]\r\n#> [1] TRUE TRUE TRUE\r\n#> \r\n#> [[7]]\r\n#> [1]  TRUE FALSE  TRUE\r\n#> \r\n#> [[8]]\r\n#> [1]  TRUE FALSE FALSE\r\n\r\ngray2bin(g[[8]])\r\n#> [1] 1 1 1\r\n```\r\n\r\nSpecial Case\r\n------------\r\n\r\nBe aware about this kind of notation »0xAF«. Because Gnu R converts this to an integer first and then it will be converted to a binary digit. This is just a limitation, if you want to use a little endian formation. It can be fixed by using switchEndianess setting the stickyBits=TRUE.\r\n\r\n``` r\r\n#Watch out for this notation\r\nas.binary(0xAF, littleEndian=TRUE)\r\n#> [1] 1 1 1 1 0 1 0 1\r\n\r\nlittleEndian <- switchEndianess(as.binary(0xAF), stickyBits = TRUE)\r\nlittleEndian\r\n#> [1] 1 0 1 0 1 1 1 1\r\nsummary(littleEndian)\r\n#>   Signedness     Endianess value<0 Size[bit] Base10\r\n#> 1   unsigned Little-Endian   FALSE         8    245\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}